冒泡排序算法步骤：
它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
走访数列的工作是重复地进行直到没有再需要交换后完成排序。

以下面5个无序的数据为例：
40 8 15 18 12 （文中仅细化了第一趟的比较过程）
第1趟: 8 15 18 12 40
![](http://my.csdn.net/uploads/201208/27/1346038661_9237.jpg)
第2趟: 8 15 12 18 40
第3趟: 8 12 15 18 40
第4趟: 8 12 15 18 40

```javascript
let arr = [40, 8, 15, 18, 12];

function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }

  return arr;
}

console.log(bubbleSort(arr)) // [ 8, 12, 15, 18, 40 ]
```

最佳情况：T(n) = O(n)
当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….）

最差情况：T(n) = O(n2)
当输入的数据是反序时(卧槽，我直接反序不就完了….)

平均情况：T(n) = O(n2)

平均时间复杂度：O(n2)
空间复杂度：O(1)  (用于交换)
稳定性：稳定


沉底的操作 一次遍历会将最大的值找到放在最后一位 第二次找到第二大
```
排序前：40,8,15,18,12
排序中!!调整：8,40,15,18,12
排序中!!调整：8,15,40,18,12
排序中!!调整：8,15,18,40,12
排序中!!调整：8,15,18,12,40
排序后：8,15,18,12,40
-------------------
排序前：8,15,18,12,40
排序中!!不调整：8,15,18,12,40
排序中!!不调整：8,15,18,12,40
排序中!!调整：8,15,12,18,40
排序后：8,15,12,18,40
-------------------
排序前：8,15,12,18,40
排序中!!不调整：8,15,12,18,40
排序中!!调整：8,12,15,18,40
排序后：8,12,15,18,40
-------------------
排序前：8,12,15,18,40
排序中!!不调整：8,12,15,18,40
排序后：8,12,15,18,40
-------------------
最终结果:8,12,15,18,40
```